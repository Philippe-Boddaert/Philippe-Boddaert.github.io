<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Bloc 6 : Algorithmique</title>
		<!-- Gestion des scripts en fonction du mode de présentation -->
		<script src="../../commun/commun.js" type="text/javascript"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section id="6.6.1" data-menu-title="6.6.1 - Recherche dichotomique">
						<h1>Recherche dichotomique</h1>
						<hr />
						<p class="img-container"><img src="./sphinx.jpg"/></p>
				</section>
				<section id="6.6.2" data-menu-title="6.6.2 - Jeu du Sphinx">
						<h2>Le jeu du Sphinx</h2>
					<p>Vous êtes "Le Sphinx", un être dôté de pouvoirs exceptionnel de divination.
						<br/>Vous demandez à un passant de choisir un nombre entre 1 et 100, et le garde secret.
						<br/>Vous pariez avec ce passant 100€ que vous pouvez déterminer le nombre qu'il a choisi en moins de 7 propositions. Si vous trouvez le nombre en moins de 7 tentatives, vous gagnez 100€, sinon le passant gagne cette somme.
						<br/>À chaque proposition fausse, le passant vous donne une indication "c'est plus" (si le nombre recherché est plus grand) ou "c'est moins".
					</p>
				</section>
				<section>
					<p>Pour impressionner le passant, vous lui proposez de choisir un nombre entre 1 et 4 milliards et vous certifiez pouvoir le trouver en moins de 32 propositions.</p>
					<div class="boiteQuestions">
						<p>Qui veut parier avec "le Sphinx"... sachant qu'il gagne toujours ?</p>
					</div>
				</section>
				<section>
					<p>La solution naïve consiste à énumérer les nombres les uns après les autres, sans utiliser les indications. On commence par 1, puis on poursuit avec 2, etc.</p>
					<p>Dans le pire des cas, on risque donc de compter jusqu'à 100...ou 4 milliards (on dira donc que la complexité de cet algorithme est de O(N), N étant le nombre de possibilités).</p>
				</section>
				<section>
					<div class="boiteQuestionsReponse">
						<p>Comment "Le Sphinx" procède-t-il ?</p>
						<div class="boiteReponses">
							<div class="reponse">
								<p>"Le Sphinx" n'a aucun don particulier...Il sait juste convertir un nombre en binaire et connait la recherche dichotomique.</p>
							</div>
						</div>
					</div>
				</section>
				<section>
					<p>Imaginons que "Le Sphinx" commence par proposer 50. Quelque soit la réponse du passant, on peut éliminer 50 possibilités :</p>
						<ul>
							<li>Si c'est plus que 50, la solution est entre 50 et 100 ;</li>
							<li>Si c'est moins, la solution est entre 1 et 50.</li>
							<li>Et ainsi de suite...</li>
						</ul>
				</section>
				<section>
					<p>Soit l'algorithme "Le Sphinx" suivant</p>
					<pre><code class="language-python" data-noescape>Algorithme : "Le Sphinx"
Entrée : n, nombre maximal choisi par le passant
Sortie : Le nombre de tentatives effectuées
Début
d ← 1
f ← n
mystere ← demander(1, n)
proposition ← n // 2
tentative ← 1
Tant que d <= f ET proposition != mystere
	Si proposition > mystere alors
		d = proposition
	Sinon
		f = proposition
	Finsi
	proposition = (d + f) // 2
	tentative ← tentative + 1
FinTantQue
Renvoyer tentative
Fin</code></pre>
				</section>
				<section>
					<h2>Complexité</h2>
					<div class="boiteTravail">
						<p>Convertir les nombres 100 et 4 milliards en binaire.</p>
						<p>Établir un lien entre la représentation binaire du nombre possibles de choix du passant et le nombre de tentatives maximales annoncées par "Le Sphinx".</p>
					</div>
				</section>
				<section>
					<p>Pour étudier la complexité, nous allons nous intéresser à la boucle : au niveau de la boucle, combien doit-on effectuer d'itérations pour un tableau de taille n dans le cas le plus défavorable ?
						<br/>Sachant qu'à chaque itération de la boucle on divise le tableau en 2, cela revient donc à se demander combien de fois faut-il diviser le tableau en 2 pour obtenir, à la fin, un tableau comportant un seul entier ? Autrement dit, combien de fois faut-il diviser n par 2 pour obtenir 1 ?
					</p>
				</section>
				<section>
					<p>Mathématiquement cela se traduit par l'équation $\frac{n}{2^a} = 1$ avec $a$ le nombre de fois qu'il faut diviser $n$ par 2 pour obtenir 1. Il faut donc trouver $a$ !
						<br/>A ce stade il est nécessaire d'introduire une nouvelle notion mathématique : le "logarithme base 2" noté $\log_2$.<br/>Par définition, $\log_2(2^x) = x$
						<br/>Nous avons donc :
						$\frac{n}{2^a} = 1 \implies n=2^a \implies \log_2(n)=\log_2(2^a)=a$, nous avons donc $a = \log_2(n)$
					</p>
				</section>
				<section>
					<p>
						Cet algorithme est donc beaucoup plus efficace que l'algorithme naïf.
					</br>En effet, dans le pire des cas, pour un intervalle entre 1 et 100, seules $\log_2(100)=7$ propositions sont nécessaires.
					</p>
				</section>
				<section id="6.6.3" data-menu-title="6.6.3 - Recherche d'un entier dans un tableau trié">
					<h1>Recherche dichotomique d'un entier</h1>
				</section>
			</div>
		</div>

		<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js" integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.3/build/highlight.min.js"></script>
		<script src="https://kit.fontawesome.com/5432c69a6f.js" crossorigin="anonymous"></script>
		<script src="../../lib/reveal/js/reveal.js"></script>
		<script type="text/javascript">
			initMode({ header : 'Bloc 6 - Algorithmique'});
			hljs.initHighlightingOnLoad();
		</script>
	</body>
</html>
