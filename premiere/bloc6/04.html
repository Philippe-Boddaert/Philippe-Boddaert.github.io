<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Bloc 6 : Algorithmique</title>
		<!-- Gestion des scripts en fonction du mode de présentation -->
		<script src="../../commun/commun.js" type="text/javascript"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section >
						<section id="6.4.1" data-menu-title='6.4.1 - Preuve de programme'>
							<h1>Preuve de programme <a href="#haut">&#x21E7;</a></h1>
							<hr />
					</section>
					<section>
						<p>
							Exécuter l'algorithme sur quelques cas ne permet pas de valider qu'il effectue correctement ce qui est attendu de lui.
							<br>Il faut donc pouvoir utiliser un système de preuve de programme.
						</p>
						<div class='boiteQuestions'>
							<p>
								Illustration avec l'algorithme de gonflage de ballon.
								<pre><code class="language-python">Algorithme gonflerBallon(ballon)
Entrée : ballon
Sortie : &Oslash;
Effet de bord : A la fin de l&#39;algorithme, le ballon est gonflé.
  Début
    Tant que ballon non gonflé faire
      soufflerDans(ballon)
    FinTantQue
  Fin</code></pre>
							</p>
						</div>
          </section>
          <section>
						<div class="boiteSynthese">
							<p>Face à un algorithme, il faut se poser et répondre à 3 questions :</p>
							<ul>
								<li>Est-ce-qu’il donne un résultat ? <i>S'arrête-t-il ?</i></li>
								<li>Est-ce-qu’il donne le résultat attendu ? <i>ou bien est-ce-qu’il calcule n’importe quoi ?</i></li>
								<li>Est-ce-qu’il donne le résultat en un temps raisonnable ? <i>ou bien est-ce-qu’il faut attendre plusieurs siècles ?</i></li>
							</ul>
						</div>
					</section>
				</section>
				<section >
					<section id="6.4.2" data-menu-title="6.4.2 - Terminaison">
						<h1>Terminaison</h1>
						<p>
							Un algorithme termine si l'ensemble de ses instructions terminent.
						</p>
					</section>
					<section>
						<div class='boiteQuestionsReponse'>
							<p>
								Est-ce que l'algorithme suivant termine ? Est-ce qu'il est correct ?
								<pre><code class="language-python">Algorithme fois2(x)
Entrée : x, entier
Sortie : entier, correspondant à 2 * x
  Début
    resultat &larr; 2 * x
    Renvoyer resultat
  Fin</code></pre>
							</p>
							<div class="boiteReponses">
								<div class="reponse column">
									<p>Le nombre d’instructions à effectuer est connu à l’avance. L'algorithme est composé de 3 opérations élémentaires (*, &larr; et un renvoi) qui terminent.</p>
								</div>
							</div>
						</div>
					</section>
					<section>
						<div class='boiteQuestionsReponse'>
							<p>
								Est-ce que l'algorithme suivant termine ?
								<pre><code class="language-python">Algorithme ageHumain(x)
Entrée : x, entier
Sortie : entier, correspondant à l'age animal
  Début
    Si x ≥ 19 alors
      y <- 10 * x − 90
    Sinon
      Si x ≥ 17 alors
        y <- 6 * x − 14
      Sinon
        Si x ≥ 2 alors
          y <- 4 * x + 20
        Sinon
          y <- 8 * x + 12
        FinSi
      FinSi
    FinSi
    Renvoyer y
  Fin</code></pre>
							</p>
							<div class="boiteReponses">
								<div class="reponse column">
									<p>L'algorithme n'est composé que d'opérations élémentaires qui terminent.</p>
								</div>
							</div>
						</div>
					</section>
					<section>
						<div class='boiteQuestionsReponse'>
							<p>
								Est-ce que l'algorithme suivant termine ?
								<pre><code class="language-python">Algorithme somme(n)
  Début
    s <- 0
    Pour i de 1 à n faire
      s <- s + i
    FinPour
    Renvoyer s
  Fin</code></pre>
							</p>
              <div class="boiteReponses">
                <div class="reponse column">
                  <p>Il y a une boucle, mais le nombre de passages dans la boucle est connu a priori. Donc l’algorithme se termine toujours.</p>
                </div>
              </div>
            </div>
					</section>
					<section>
						<div class='boiteQuestions'>
							<p>
								Est-ce que l'algorithme suivant termine ?
								<pre><code class="language-python">Algorithme mystere(x)
Début

Fin</code></pre>
							</p>
						</div>
					</section>
					<section>
						<h3>Comment déterminer qu'un algorithme termine ?</h3>
						<p>On peut voir, par le biais des exemples ci-dessous, qu'en lisant la suite des instructions, nous avons l'intuition que les algorithmes terminent.
							<br>Pour des algorithmes avec plus d'instructions, il nous faut un moyen formel de prouver la terminaison d'un algorithme.
						</p>
					</section>
					<section>
						<blockquote>Toute suite d’entiers naturels strictement décroissante est finie.<footer>3ème axiome fondamental de l'arithmétique</footer></blockquote>
						<p>Il n’existe pas de suite infinie d'entiers naturels strictement décroissante.</p>
						<p>Pour prouver la terminaison d'un algorithme, il suffit de trouver un entier naturel strictement décroissant pendant l'exécution de l'algorithme.</p>
					</section>
					<section>
						<p>
							Cet entier est appelé <span class="highlight">variant de boucle</span>. Pour identifier si une boucle se termine effectivement, il faut : </p>
							<ul>
								<li>identifier le variant de boucle et vérifier qu’il est positif,</li>
								<li>vérifier qu’il décroît effectivement et strictement à chaque itération,</li>
								<li>Dans le cas contraire, on rencontre une boucle infinie.</li>
							</ul>
					</section>
					<section>
					</section>
					<section>
						<div class="boiteQuestionsReponse">
							<p>
								Existe-t-il un algorithme qui permet de dire si un algorithme termine ?
							</p>
							<div class="boiteReponses">
								<div class="reponse row">
									<img src='../turing.jpg' width="20%"></img>
									<p>Alan Turing en 1936 a prouvé que le problème de l'arrêt est indécidable, c'est-à-dire qu'il n'existe pas de programme informatique qui prend comme entrée une description d'un programme informatique avec toutes ses entrées et qui, grâce à la seule analyse de ce code, répond VRAI si le programme s'arrête sur son paramètre et FAUX sinon.</p>
								</div>
							</div>
						</div>
					</section>
				</section>
				<section>
					<section id='6.4.3' data-menu-title='6.4.3 - Correction'>
					</section>
				</section>
				<section>
					<section id="6.4.4" data-menu-title="6.4.4 - Complexité">
						<h1>Complexité</h1>
						<p class='img-container'>
							<img src='../complexité.jpg'/>
						</p>
					</section>
					<section id="6.4.4.1" data-menu-title='6.4.4.1 - Définition'>
						<h1>Définition</h1>
						<ul>
							<li>Combien de temps prend un algorithme pour s'exécuter ?</li>
							<li>Quelle quantité de mémoire utilise-t-il au cours de son exécution ?</li>
						</ul>
						<p>La notion de complexité d'un algorithme va permettre de répondre à ces 2 questions.</p>
					</section>
					<section>
						<p>La complexité d'un algorithme c'est une mesure d'efficacité (temporelle et spatiale) qui permet de comparer des algorithmes solutionnant le même problème.
							<br/>On dira qu'un algorithme A est plus efficace en temps qu'un algorithme B, si sa complexité en temps est moindre que celui de l'algorithme B.
							<br/>Nous nous intéresserons uniquement à la complexité en temps.
						</p>
					</section>
					<section>
						<h2>Comment calculer la complexité ?</h2>
						<p>Une mesure naturelle de la complexité d'un algorithme serait d'exécuter l'algorithme et calculer le temps d'exécution réel. Il s'agit d'une très mauvaise mesure. En effet, elle dépend de beaucoup de paramètres : le compilateur, le langage de programmation, la machine,...</p>
						<p>C'est pourquoi la mesure de complexité utilisée est le nombre d'opérations de l'algorithme. Cette mesure a l'avantage d'être indépendante de la machine et du langage, et d'être évaluable sur le papier.</p>
					</section>
					<section id="6.4.4.2" data-menu-title="6.4.4.2 - Illustration">
						<p>Soit un tableau $T$ un tableau d'entiers et $x$, un entier. Ci dessous, l'algorithme est_present qui détermine si $x$ est présent dans $T$.</p>
						<pre><code class="language-python">Algorithme est_present(T, x)
Entrée :
Sortie :
Début
  present &larr; FAUX
  n &larr; taille(T)
  Pour i variant de 0 à n
    Si T[i] = x alors
      present &larr; VRAI
    FinSi
  FinPour
  Renvoyer present
Fin</code></pre>
					</section>
					<section>
						<div class="boiteQuestionsReponse">
							<p>Calculer le nombre d'opérations executées par l'algorithme est_present.</p>
							<div class="boiteReponses">
								<div class="reponse column">
									<p>On se rend compte que le nombre d'opérations dépend :</p>
									<ul>
										<li>du nombre d'opérations de l'algorithme Taille,</li>
										<li>des différents cas renvoyés par l'algorithme,</li>
										<li>de la taille du tableau $T$</li>
									</ul>
								</div>
							</div>
						</div>
					</section>
					<section>
						<p>Cas 1 : $x$ n'est pas présent dans $T$</p>
						<pre><code class="language-python">Algorithme est_present(T, x)
Entrée :
Sortie :
Début
  present &larr; FAUX               # 1 opération
  n &larr; taille(T)                # 1 opération<sup>*</sup>
  Pour i variant de 0 à n - 1   # n opérations
    Si T[i] = x alors           # 2 * n opérations
      present &larr; VRAI
    FinSi
  FinPour
  Renvoyer present              # 1 opération
Fin</code></pre>
						<p class="fragment">Le nombre total d'opérations $= 1 + 1 + 3 \times n + 1 = 3n + 3$</p>
					</section>
					<section>
						<p>Cas 2 : $x$ est présent dans $T$</p>
						<pre><code class="language-python">Algorithme est_present(T, x)
Entrée :
Sortie :
Début
  present &larr; FAUX               # 1 opération
  n &larr; taille(T)                # 1 opération<sup>*</sup>
  Pour i variant de 0 à n - 1   # n opérations
    Si T[i] = x alors           # 2 * n opérations
      present &larr; VRAI           # 1 opération
    FinSi
  FinPour
  Renvoyer present              # 1 opération
Fin</code></pre>
						<p class="fragment">Le nombre total d'opérations $= 1 + 1 + 3 \times n + 1 + 1 = 3n + 4$, ce, quelque ce soit la position de $x$ dans $T$</p>
					</section>
					<section>
						<p>Nous venons de voir que la complexité dépend de la taille du tableau $T$, plus le tableau est grand et plus le nombre d'opérations à effectuer est important.
							<br>Pour effectuer des comparaisons entre plusieurs algorithmes, nous allons raisonner sur des tableaux de grande taille, car plus les tableaux sont grands et plus les différences entre les algorithmes seront flagrantes.
							<br>Pour comparer des algorithmes, nous allons donc uniquement nous intéresser à ce que l'on appelle "l'ordre de grandeur asymptotique"
						</p>
					</section>
					<section id="6.4.4.3" data-menu-title='6.4.4.3 - Ordre de grandeur'>
						<h1>Ordre de grandeur asymptotique</h1>
						<p>C'est une échelle de référence, qui considère les cas où l'ensemble des données en jeu est très grand.
							<br>On note cet ordre de grandeur avec un $\mathcal{O}$ majuscule.
						</p>
					</section>
					<section>
						<p>En reprenant l'exemple de l'algorithme est_present, le nombre de comparaisons calculé est $3n + 4$.
						<br>Ce qui correspond à un ordre de grandeur asymptotique en $\mathcal{O}(n)$</p>
					</section>
					<section>
						<p>Pour obtenir l'ordre de grandeur à partir d'un polynome :</p>
						<ul>
							<li>Supprimer les constantes</li>
							<li>Garder uniquement le $n$ qui possède l'exposant le plus grand</li>
							<li>Supprimer le coefficient devant le $n$</li>
						</ul>
						<p class="fragment">Exemples : <br>
							$$3n + 4 \Rightarrow {\color{red}\cancel{3}} n + {\color{red}\cancel{4}} \Rightarrow \mathcal{O}(n)$$
						$$6n^2 + 3n + 5 \Rightarrow {\color{red}\cancel{6}} n^2 + {\color{red}\cancel{3n}} + {\color{red}\cancel{5}} \Rightarrow \mathcal{O}(n^2)$$</p>
					</section>
					<section>
						<div class="boiteTravail">
							<p>1. Écrire une version de l'algorithme est_present avec une boucle while, qui permet de déterminer si $x$ est présent dans le tableau $T$ et renvoyer cette information dès que l'algorithme trouve sa présence.</p>
							<p>2. Déterminer la complexité de cet algorithme dans le meilleur et le pire des cas.</p>
						</div>
					</section>
					<section>
						<div class="boiteTravail">
							<p>1. Écrire un algorithme permettant de trouver le plus grand entier présent dans un tableau. Vous ferez "tourner à la main" votre algorithme en utilisant le tableau t = [3,5,1,8,4,2]. </p>
							<p>2. Déterminer la complexité de cet algorithme.</p>
						</div>
					</section>
					<section>
						<p class="img-container full">
							<img src="../comparaison_complexite.png"/>
						</p>
					</section>
					<section>
						<p>Voici un tableau dans lequel le temps de calcul de différentes complexités algorithmiques est présenté, en fonction de la taille des données.</p>
						<table class='responsive'>
							<thead>
								<tr>
									<th></th>
									<th>$n = 1$</th>
									<th>$n = 10$</th>
									<th>$n = 100$</th>
									<th>$n = 1000$</th>
									<th>$n = 1000000$</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<th>$\mathcal{O}(1)$</th>
									<td>1 &micro;s</td>
									<td>1 &micro;s</td>
									<td>1 &micro;s</td>
									<td>1 &micro;s</td>
									<td>1 &micro;s</td>
								</tr>
								<tr>
									<th>$\mathcal{O}(\log{}n)$</th>
									<td>1 &micro;s</td>
									<td>4 &micro;s</td>
									<td>7 &micro;s</td>
									<td>10 &micro;s</td>
									<td>20 &micro;s</td>
								</tr>
								<tr>
									<th>$\mathcal{O}(n)$</th>
									<td>1 &micro;s</td>
									<td>10 &micro;s</td>
									<td>100 &micro;s</td>
									<td>1 ms</td>
									<td>1 s</td>
								</tr>
								<tr>
									<th>$\mathcal{O}(n\log{}n)$</th>
									<td>1 &micro;s</td>
									<td>4 &micro;s</td>
									<td>700 &micro;s</td>
									<td>10 ms</td>
									<td>20 s</td>
								</tr>
								<tr>
									<th>$\mathcal{O}(n^2)$</th>
									<td>1 &micro;s</td>
									<td>100 &micro;s</td>
									<td>10 ms</td>
									<td>1 s</td>
									<td>11.57 jours</td>
								</tr>
								<tr>
									<th>$\mathcal{O}(n^3)$</th>
									<td>1 &micro;s</td>
									<td>1 ms</td>
									<td>1 s</td>
									<td>16.67 min</td>
									<td>31709 ans</td>
								</tr>
								<tr>
									<th>$\mathcal{O}(2^n)$</th>
									<td>2 &micro;s</td>
									<td>1.024 ms</td>
									<td>401969368413314 siècles</td>
									<td>-</td>
									<td>-</td>
								</tr>
								<tr>
									<th>$\mathcal{O}(n!)$</th>
									<td>1 &micro;s</td>
									<td>3.62 s</td>
									<td>2.9e+142 siècles</td>
									<td>-</td>
									<td>-</td>
								</tr>
							</tbody>
						</table>
					</section>
				</section>
			</div>
		</div>

		<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js" integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.3/build/highlight.min.js"></script>
		<script src="https://kit.fontawesome.com/5432c69a6f.js" crossorigin="anonymous"></script>
		<script src="../../lib/reveal/js/reveal.js"></script>
    <script src="sorter.js" type="text/javascript"></script>
		<script type="text/javascript">
			initMode({ header : '6.4 - Preuves de programme'});
			hljs.initHighlightingOnLoad();

			function isInView(elem){
			   return window.scrollY < elem.offsetHeight + elem.offsetTop;
			}

			window.addEventListener('scroll', function(){
				let sections = document.querySelectorAll('section[data-menu-title]');
				i = 0;
				while (i < sections.length && !isInView(sections[i]))
					i++;
				if (i < sections.length)
 			  	console.log(sections[i].dataset.menuTitle);

			});
		</script>
	</body>
</html>
