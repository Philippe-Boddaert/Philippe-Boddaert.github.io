<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Bloc 5 : Algorithmique</title>
		<!-- Gestion des scripts en fonction du mode de présentation -->
		<script src="../../commun/commun.js" type="text/javascript"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section id="5.4.1" data-menu-title='5.4.1 - Contexte'>
						<figure class="img-container">
							<img src="Philippe II.jpg" />
							<figcaption>Philippe II de Macédoine<br/>Source : Wikimedia</figcaption>
						</figure>
					</section>
					<section>
						<h1>Diviser pour règner</h1>
						<p>Stratégie politique qui vise à susciter des oppositions et des luttes afin de les utiliser pour assurer son autorité.</p>
						<p>Ce principe a été référencé bien avant notre époque et la création des premiers ordinateurs :</p>
							<ul>
								<li>dès le VI<sup>ème</sup> avant J.-C., dans <i>L'art de la guerre</i> de <b>Sun Tzu</b>,</li>
								<li>appliqué par <b>Philippe II de Macédoine</b> au IV<sup>ème</sup> avant J.-C.,</li>
								<li>au XVI<sup>ème</sup> siècle dans <i>Le Prince</i> de <b>Machiavel</b>.</li>
							</ul>
					</section>
					<section>
						<p>Appliquer au champ de l'algorithmique, cette stratégie consiste à :</p>
							<ul>
								<li>considérer un problème, difficile à résoudre au premier abord,</li>
								<li>de le diviser en une multitude de sous-problèmes, plus simples à résoudre que le problème originel.</li>
								<li>Une fois, ces "sous-problèmes" résolus, on les recombine pour obtenir la solution au problème de départ.</ul>
					</section>
					<section>
						<p>Le paradigme "diviser pour régner" repose donc sur 3 étapes :</p>
						<ul>
							<li>DIVISER : le problème d'origine est divisé en un certain nombre de sous-problèmes</li>
							<li>RÉGNER : on résout les sous-problèmes (les sous-problèmes sont plus faciles à résoudre que le problème d'origine)</li>
							<li>COMBINER : les solutions des sous-problèmes sont combinées afin d'obtenir la solution du problème d'origine.</li>
						</ul>
<p>Les algorithmes basés sur le paradigme "diviser pour régner" sont très souvent des algorithmes récursifs.</p>
					</section>
				</section>
				<section id="5.4.2" data-menu-title="5.4.2 - Calcul du minimum d'une liste">
				</section>
				<section id="5.4.3" data-menu-title="5.4.3 - Tri fusion">
				</section>
					<section>
						<section id="5.4.4" data-menu-title="5.4.4 - Complexité">
							<h1>Théorème sur les récurrences de partition</h1>
							<p>Autrement nommé, "Master Theorem", il permet d'obtenir une solution en termes asymptotiques pour des relations de récurrence d'un certain type rencontrées dans l'analyse de complexité d'algorithmes qui sont régis par le paradigme "diviser pour régner".</p>
						</section>
						<section>
							<p>Soient $a \geq 1$, $b > 1$ et T la relation de récurrence suivante :
							$$ T(n)=a\;T\left({\frac {n}{b}}\right)+\mathcal{O}(n^{c})$$

							Les différents paramètres s'interprètent comme suit :
						</p>
							<ul>
								<li>$n$ est la taille du problème,</li>
								<li>$a$ est le nombre de sous-problèmes,</li>
								<li>$\frac{n}{b}$ est le taille de chaque sous-problèmes.</li>
								<li>$\mathcal{O(n^c)}$ est le coût de la subdivision et de la combinaison des solutions des sous-problèmes.</li>
							</ul>
						</section>
						<section>
							<p>Le "Master Theorem" permet d'obtenir une expression de la complexité de $T(n)$ comme suit :</p>
							<ol>
								<li>Si $a < b^c$ alors $T(n)=\mathcal{O}(n^c)$.</li>
								<li>Si $a = b^c$ alors $T(n)=\mathcal{O}(n^{c}\log n)$.</li>
								<li>Si $a > b^c$ alors $T(n)=\mathcal{O}(n^{\log_b a})$.</li>
							</ol>
							</p>
						</section>
						<section>
							<h2>Application à des algorithmes courants</h2>
	<table>
		<thead>
			<tr>
				<th>Algorithme</th>
				<th>Relation de récurrence</th>
				<th>Complexité en temps</th>
				<th>Commentaire</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Recherche dichotomique</td>
				<td>$T(n) = T\left(\frac{n}{2}\right) + O(1)$</td>
				<td>$\mathcal{O}(\log n)$</td>
				<td>Appliquer le « master theorem » avec $ a = 1, b = 2, c = 0$, le cas 3 s'applique.</td>
			</tr>
			<tr>
				<td>Parcours d'arbre binaire</td>
				<td>$T(n) = 2\,T\left(\frac{n}{2}\right) + O(1)$</td>
				<td>$\mathcal{O}(n)$</td>
				<td>Appliquer le « master theorem » avec $ a = 2, b = 2, c = 0$, le cas 2 s'applique.</td>
			</tr>
			<tr>
				<td>Trouver la valeur médiane</td>
				<td>$T(n) = T\left(\frac{n}{2}\right) + O(n)$</td>
				<td>$\mathcal{O}(n)$</td>
				<td>Appliquer le « master theorem » avec $ a = 1, b = 2, c = 1$, le cas 1 s'applique.</td>
			</tr>
			<tr>
				<td>Tri fusion</td>
				<td>$T(n) = 2\,T\left(\frac{n}{2}\right) + O(n)$</td>
				<td>$\mathcal{O}(n \log n)$</td>
				<td>Appliquer le « master theorem » avec $ a = 2, b = 2, c = 1$, le cas 2 s'applique.</td>
			</tr>
		</tbody>
	</table>
						</section>
					</section>
			</div>
		</div>

		<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js" integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.3/build/highlight.min.js"></script>
		<script src="https://kit.fontawesome.com/5432c69a6f.js" crossorigin="anonymous"></script>

		<script src="../../lib/reveal/js/reveal.js"></script>

		<script type="text/javascript">
			initMode({
				header : 'Bloc 5.4 : Méthode "Diviser pour règner"'
			});
    </script>
	</body>
</html>
