<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Bloc 4 : Langages et Programmation</title>
		<!-- Gestion des scripts en fonction du mode de pr√©sentation -->
		<script src="../../commun/commun.js" type="text/javascript"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section id='4.3.1' data-menu-title='4.3.1 - Contexte'>
							<h1>R√©cursivit√©</h1>
							<hr />
							<p class="img-container">
								<img class="third-width" src="../vache_qui_rit.jpg" />
								<img class="third-width" src="../poupee_russe.jpg" />
								<img class="third-width" src="../droste.jpg" />
							</p>
					</section>
					<section>
							<p>Point commun entre ces 3 photos : elles comportent toutes une structure <span class='highlight'>r√©cursive</span>.</p>
							<ul>
								<li>Une poup√©e russe, c‚Äôest une poup√©e avec une poup√©e russe √† l‚Äôint√©rieur.</li>
								<li>Une boite de vache qui rit c'est une boite qui contient une photo de vache qui a une boucle d'oreille en forme de boite qui contient une photo de vache qui a une boucle d'oreille...</li>
							</ul>
					</section>
					<section>
						<p>En programmation, nombreux sont les probl√®mes qu‚Äôon r√©sout en r√©p√©tant plusieurs fois des s√©quences d‚Äôinstructions (par le biais de boucles born√©es ou non).
							<br>Mais certains probl√®mes se r√©solvent simplement en r√©solvant un sous probl√®me de m√™me nature, mais plus simple.
							<br>Cette m√©thode de r√©solution s‚Äôappelle la r√©cursivit√©.</p>
					</section>
				</section>
					<section id='4.3.2' data-menu-title='4.3.2 - D√©finition'>
						<h1>D√©finition</h1>
						<blockquote>Propri√©t√© que poss√®de une r√®gle ou un √©l√©ment constituant de pouvoir se r√©p√©ter de mani√®re th√©oriquement ind√©finie.</blockquote>
					</section>
					<section>
						<section id='4.3.3' data-menu-title='4.3.3 - Illustrations'>
							<h1>Illustrations</h1>
						</section>
						<section id='4.3.3.1' data-menu-title="4.3.3.1 - Factorielle d'un entier">
							<h2>Factorielle d'un entier naturel</h2>
							<p>
							La fonction math√©matique factorielle de $n$ s'exprime par :
	$$\begin{align*}
	n! = \prod _{1\leqslant i\leqslant n}i & = n \times (n - 1) \times (n - 2) ... \times 1\\ & = n \times \underbrace{{\color{red}{(n - 1) \times (n - 2) ... \times 1}}}_{(n - 1)!}\\& = n \times (n - 1) !
	\end{align*}$$
							</p>
						</section>
						<section>
							<div class="boiteTravail">
								&Eacute;crire l'algorithme r√©cursif, qui prend en param√®tre un entier $n$, et renvoie la factorielle de $n$.
							</div>
						</section>
						<section id='4.3.3.2' data-menu-title="4.3.3.2 - Somme des premiers termes">
							<h2>Somme des premiers termes</h2>
							<p>
							La fonction math√©matique Somme des $n$ premiers termes, pour $n \in \mathbb{N}$ s'exprime par :
	$$\begin{align*}
	\sum_{i=1}^{n} i & =  1 + 2 + 3 + ... + n \\
	& = 1 + \underbrace{{\color{red}{2 + 3 + ... + n}}}_{\sum_{i=2}^{n} i } \\
	& = 1 + 2 + \underbrace{{\color{red}{3 + ... + n}}}_{\sum_{i=3}^{n} i }
	\end{align*}$$
							</p>
						</section>
					<section>
						<div class="boiteTravail">
							&Eacute;crire l'algorithme r√©cursif, qui prend en param√®tre un entier $n$, et renvoie la somme des entiers jusque $n$.
						</div>
					</section>
						<section id='4.3.3.3' data-menu-title="4.3.3.3 - Parit√© d'un entier">
							<h2>Parit√© / Imparit√© d'un entier naturel</h2>
							<p>On sait que 0 est pair, et 1 impair.</p>
								<ul>
									<li>Pour tout $n \geq 2$, que peut-on dire de pair($n$) par rapport √† pair($n - 2$), de pair ($n - 4$) ...?</li>
									<li>Pour tout $n \geq 2$, que peut-on dire de impair($n$) par rapport √† de impair($n - 2$), de impair ($n - 4$) ...?</li>
								</ul>
						</section>
						<section>
							<div class="boiteTravail">
								<p>&Eacute;crire un algorithme r√©cursif pair, prenant un entier n en param√®tre, et renvoie Vrai si $n$ est pair, Faux sinon.</p>
								<p>&Eacute;crire un algorithme r√©cursif impair, prenant un entier n en param√®tre, et renvoie Vrai si $n$ est impair, Faux sinon.</p>
							</div>
						</section>
						<section>
							<p>Que peut-on dire de :
								<ul>
									<li>pair(12) par rapport √† impair(11) ?</li>
									<li>impair(7) par rapport √† pair(6) ?</li>
									<li>pair($n$) par rapport √† impair($n - 1$) ?</li>
									<li>impair($n$) par rapport √† ($n - 1$) ?</li>
								</ul>
							</p>
						</section>
						<section>
							<div class="boiteTravail">
								<p>Modifier l'algorithme r√©cursif pair, afin ne d'utiliser que l'algorithme impair.</p>
								<p>Modifier l'algorithme r√©cursif impair, afin ne d'utiliser que l'algorithme pair.</p>
							</div>
						</section>
				</section>
					<section id='4.3.4' data-menu-title='4.3.4 - Propri√©t√©s'>
						<h1>Propri√©t√©s</h1>
						Des travaux pr√©c√©dents, on peut tirer 2 r√®gles pour √©crire un algorithme r√©cursif :
						<ul>
							<li>R√®gle 1 : Tout algorithme r√©cursif doit distinguer plusieurs cas dont l‚Äôun au moins ne doit pas contenir d‚Äôappels r√©cursifs. Sinon, il y a risque de cercle vicieux et de calcul infini.</li>
							<li>R√®gle 2 : Tout appel r√©cursif doit se faire avec des donn√©es plus proches de donn√©es satisfaisant les conditions de terminaison.</li>
						</ul>
							<p>Deux algorithmes sont mutuellement r√©cursifs si l‚Äôun fait appel √† l‚Äôautre et l‚Äôautre √† l‚Äôun.</p>
					</section>
					<section>
						<p>Voici le d√©roulement du calcul r√©cursif de 4! :
							$$
							\begin{align*}
							fact(4) & = 4 \times fact(3) \\
							& = 4 \times 3 \times fact(2) \\
							& = 4 \times 3 \times 2 \times fact(1) \\
							& = 4 \times 3 \times 2 \times 1 \times fact(0) \\
							& = 4 \times 3 \times 2 \times 1 \times 1 \\
							& = 24
							\end{align*}
							$$
							On note que des calculs restent en attente, jusqu‚Äô√† ce qu‚Äôon atteigne le cas o√π il ne reste plus d‚Äôappel √† la fonction ùöèùöäùöåùöù dans l‚Äôexpression √† calculer.</p>
					</section>
					<section data-menu-title='D√©recursiver'>
					</section>
					<section data-menu-title='Probl√®me des tours de Hanoi'>
						<div class="boiteTravail">
							<p>
								Regarder et r√©pondre aux questions pos√©es durant la vid√©o.
							</p>
							<p class="center">
								<video class="half-width" controls="true" src="../enigmatique-les-tours-dhanoi.mp4" type="video/mp4"></video>
							</p>
						</div>
					</section>
					<section>
						<div class='boiteTravail'>
							<p>&Eacute;crire l'algorithme r√©cursif hanoi, qui prend en param√®tres :</p>
								<ul>
									<li>$n$ : le nombre de disques √† d√©placer,</li>
									<li>$d$ : le num√©ro de disque de d√©part,</li>
									<li>$i$ : le num√©ro de disque interm√©diaire,</li>
									<li>$a$ : le num√©ro de dique d'arriv√©e.</li>
								</ul>
								<p> et a pour effet de bord de d√©placer tous les disques dans le bon ordre sur le disque d'arriv√©e.</p>
						</div>
					</section>
					<section>
						<div class='boiteSynthese'>
							<p>Un algorithme r√©cursif s'appelle lui-m√™me sur un ensemble de donn√©es d√©croissant jusqu'√† atteindre des cas de bases.</p>
						</div>
					</section>
			</div>
		</div>

		<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js" integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.3/build/highlight.min.js"></script>
		<script src="https://kit.fontawesome.com/5432c69a6f.js" crossorigin="anonymous"></script>
		<script src="../../lib/reveal/js/reveal.js"></script>
		<script type="text/javascript">
			initMode({
				header : 'Bloc 4 : Langages et Programmation'
			});
			hljs.initHighlightingOnLoad();
    </script>
	</body>
</html>
